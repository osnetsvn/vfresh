\section{Related Work}
\label{sec:related}
\vspace{-0.05in}
\para{Process/Container Migration.} Process migration techniques have been extensively studied in the past \cite{spin, exokernel, synthetix, baraks, zayas, douglis, theimer, lsf, condor, criu}. In general, process migration can be implemented either in the kernel level or in the user level. Kernel level process migration techniques \cite{spin, exokernel, synthetix, baraks, zayas, douglis, theimer} are implemented either with kernel-level inherent support or by modifying the existing operating systems adding complexity. In contrast, user-level implementation \cite{lsf, condor, criu, Amoeba, Chorus, Mach} requires either to modify applications reducing the transparency or to heavily intrude processes for collecting state facing performance degradation. The performance overhead of user-level implementations can be significantly mitigated with key kernel-level support such as exposing as much state information of processes as possible to the user space and/or providing efficient ways to mark dirty pages and transfer them \cite{condor, lsf, criu}. As a container consists of a hierarchy of processes as well as mechanisms that enable isolation and security between containers, state-of-the-art container migration approaches  \cite{docker, openvz, coreos_rocket} build upon process migration. For example, the migration of Docker container \cite{docker} builds on CRIU's \cite{criu} process checkpointing and restoring mechanisms. 

\para{Live Migration.} A lot of live migration techniques have been proposed.  One approach is postcopy technique \cite{Hines:2009:PLM:1618525.1618528, zayas}, where pages are migrated only when they are referred on the destination machine. Although such an on-demand page migration reduces the initial cost of the migration, it increases the total migration time. Precopy \cite{theimer} keeps processes/containers running on the source machine while its memory keeps getting transferred to the destination in an iterative manner; once the dirtied pages are small enough, the whole process is paused and the remaining pages are transferred. If the page dirtying rate is very high, the migration will take way longer to complete. There has also been work that combines some features of these techniques \cite{lazo, loubutin, sinha, dediu, dijk,schill,petri,schrimpf} . For example, instead of copying entire memory state in the most basic technique, only the minimal dirty pages are transferred \cite{roush}. The remaining pages are transferred while the process is running on remote machine. This reduces the transfer cost, but requires the support of the remote paging mechanism. MOSIX \cite{mosix} and Sprite \cite{sprite} implements migration by leaving residual dependencies on the source machine. Although, it makes the migration simple but it requires the source machine to be available all the time till the process completes its execution. 
